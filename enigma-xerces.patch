--- enigma-1.01/configure.ac~	2007-05-25 23:28:44.000000000 +0200
+++ enigma-1.01/configure.ac	2010-11-24 00:07:13.166423002 +0100
@@ -179,7 +179,7 @@
       xerces3exp="no")      
   if test "x$xerces3exp" = xyes; then
     AC_MSG_RESULT([found])
-    AC_CHECK_LIB(xerces, main,,[AC_MSG_ERROR([xerces is required to compile Enigma])])
+    AC_CHECK_LIB(xerces-c, main,,[AC_MSG_ERROR([xerces is required to compile Enigma])])
   else
     AC_MSG_RESULT([not found])
     AC_MSG_CHECKING([for Xerces >=2.4 released version])
--- enigma-1.01/src/Utf8ToXML.cc~	2010-11-24 00:08:40.166982997 +0100
+++ enigma-1.01/src/Utf8ToXML.cc	2010-11-24 00:17:40.325982996 +0100
@@ -40,11 +40,11 @@
     }
 
     void Utf8ToXML::init(const char * const toTranscode) {
-        unsigned int srcLength = std::strlen(toTranscode) + 1;
+        XMLSize_t srcLength = std::strlen(toTranscode) + 1;
         // make safe assumptions on utf-16 size
-        unsigned int maxDestLength = srcLength;
-        unsigned int charsEaten;
-        unsigned int destLength;
+        XMLSize_t maxDestLength = srcLength;
+        XMLSize_t charsEaten;
+        XMLSize_t destLength;
         unsigned char *charSizes = new unsigned char[maxDestLength]; // just junk
         // make a buffer - size does not matter - the object is temporary 
         xmlString = new XMLCh[maxDestLength];
--- enigma-1.01/src/XMLtoUtf8.cc~	2006-01-20 12:12:12.000000000 +0100
+++ enigma-1.01/src/XMLtoUtf8.cc	2010-11-24 00:20:37.279982998 +0100
@@ -27,11 +27,11 @@
 namespace enigma
 {
     XMLtoUtf8::XMLtoUtf8(const XMLCh* const toTranscode) {
-        unsigned int srcLength = XMLString::stringLen(toTranscode) + 1;
+        XMLSize_t srcLength = XMLString::stringLen(toTranscode) + 1;
         // make safe assumptions on utf-8 size
-        unsigned int maxDestLength = 3 * srcLength;
-        unsigned int charsEaten;
-        unsigned int destLength;
+        XMLSize_t maxDestLength = 3 * srcLength;
+        XMLSize_t charsEaten;
+        XMLSize_t destLength;
         // make a buffer - size does not matter - the object is temporary 
         utf8String = new char[maxDestLength];
         // transcode to utf-8 -- there are no unrepresentable chars
--- enigma-1.01/src/lev/ScoreManager.cc.orig	2007-04-10 23:52:50.000000000 +0200
+++ enigma-1.01/src/lev/ScoreManager.cc	2010-11-24 00:31:38.370982993 +0100
@@ -61,18 +61,20 @@
 namespace {
 #if _XERCES_VERSION >= 30000
     class ScoreDomSerFilter : public DOMLSSerializerFilter {
+	public:
+	    virtual DOMNodeFilter::FilterAction acceptNode(const DOMNode *node) const;
 #else
     class ScoreDomSerFilter : public DOMWriterFilter {
-#endif
         public:
             virtual short acceptNode(const DOMNode *node) const;
+#endif
             virtual unsigned long getWhatToShow () const {
                 return DOMNodeFilter::SHOW_ALL;
             }
             virtual void setWhatToShow (unsigned long toShow) {}
     };
-    
-    short ScoreDomSerFilter::acceptNode(const DOMNode *node) const {
+   
+    DOMNodeFilter::FilterAction ScoreDomSerFilter::acceptNode(const DOMNode *node) const {
         if (node->getNodeType () == DOMNode::ELEMENT_NODE &&
                  std::string(XMLtoUtf8(node->getNodeName()).c_str()) == "level") {
             const DOMElement *e = dynamic_cast<const DOMElement *>(node);
